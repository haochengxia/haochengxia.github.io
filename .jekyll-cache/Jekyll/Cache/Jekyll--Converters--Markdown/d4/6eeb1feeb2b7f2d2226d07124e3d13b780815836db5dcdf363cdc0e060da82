I"l<blockquote>
  <p>Auther: Percy</p>

  <p>Updated at 2020/12/19</p>
</blockquote>

<h3 id="body">Body</h3>

<p>To my best knowledge, the most of the sampling based algorithm can be simply run in multi-process/parallel as we can divide the samples into parts.</p>

<p>This simple blog aims at reminding myself that we can benefit a lot with naive multiprocessing.</p>

<p>The next part is a crude example on the calculation of Shpaley value based on Monte Carlo in Python.</p>

<ul>
  <li>single processing</li>
</ul>

<pre><code class="language-python">from tqdm import trange
import numpy as np


def eval_shap(x_train, y_train, x_test, y_test):    
    for t in trange(M):
		    ''' calculate Shapley value with Monte Carlo
		    ...
		    '''
    return np.asarray(sv) # type(sv) -&gt; list
</code></pre>

<ul>
  <li>multiprocessing</li>
</ul>

<pre><code class="language-python">from tqdm import trange
from multiprocessing import Pool
from functools import partial
import numpy as np

procs_num = 5


def sub_task(x_train, y_train, x_test, y_test, ID):
    for t in trange(M / procs_num):
		    ''' calculate Shapley value with Monte Carlo
		    ...
		    '''
    # print('task of proc' + str(ID) + ' completed!')
    return sv # type(sv) -&gt; list


def eval_shap_multi_proc(x_train, y_train, x_test, y_test):
    proc_ids = [i for i in range(procs_num)]

    pool = Pool()
    func = partial(sub_task, x_train, y_train, x_test, y_test)
    ret = pool.map(func, proc_ids)
    pool.close()
    pool.join()
    ret_arr = np.asarray(ret)
    return np.sum(ret_arr, axis=0)
</code></pre>

<h3 id="time-cost-comparison">Time Cost Comparison</h3>

<blockquote>
  <p>Test on MacBook Pro (16-inch, 2019)</p>

  <p>Intel Core i7 - 6 cores 2.6GHz</p>

  <p>16 GB 2667MHz DDR4</p>
</blockquote>

<pre><code># multi
100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 6000/6000 [01:23&lt;00:00, 71.56it/s]
100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 6000/6000 [01:24&lt;00:00, 70.99it/s]
100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 6000/6000 [01:26&lt;00:00, 69.50it/s]
100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 6000/6000 [01:26&lt;00:00, 69.49it/s]
100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 6000/6000 [01:26&lt;00:00, 69.28it/s]

# single
100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 30000/30000 [06:31&lt;00:00, 76.65it/s]
</code></pre>

<p>With multiprocessing, the time cost becomes a quarter of the original.</p>

<p>And the result is certainly similar. (They use different permutations here!)</p>

<pre><code># multi
[1172.625       843.54166667 1308.43333333 1159.20833333 1560.875
 1327.68333333  991.15        762.61666667 1379.56666667  520.84166667
  994.625       906.79166667 1050.1         805.875       987.28333333
 1025.06666667  923.14166667 1115.40833333  995.43333333  760.525
  916.14166667  687.3         892.63333333  912.675      1051.75833333
 1041.11666667 1010.83333333  718.66666667  799.10833333  960.50833333]
 
# single
[1155.29166667  863.43333333 1308.04166667 1189.74166667 1561.99166667
 1379.025       970.75        798.75       1313.13333333  522.35833333
  985.5         868.38333333 1056.575       757.6        1018.25833333
 1027.33333333  936.275      1033.80833333  991.68333333  789.7
  886.95        729.475       889.26666667  908.63333333 1066.10833333
 1056.36666667 1049.075       700.33333333  822.53333333  945.99166667]
</code></pre>

<h2 id="chinese-version">Chinese Version</h2>

<h3 id="æ­£æ–‡">æ­£æ–‡</h3>

<p>åœ¨æˆ‘çš„è®¤çŸ¥ä¸­ï¼Œå¤§å¤šæ•°åŸºäºé‡‡æ ·çš„ç®—æ³•éƒ½å¯ä»¥è¢«å¾ˆç®€å•åœ°å¤šè¿›ç¨‹å¤„ç†/å¹¶è¡ŒåŒ–ï¼Œå› ä¸ºé‡‡åˆ°çš„æ ·æœ¬å¯ä»¥è¢«åˆ†æˆå¤šä¸ªéƒ¨åˆ†ã€‚</p>

<p>è¿™ç¯‡ç®€å•çš„åšæ–‡ç”¨äºæé†’æˆ‘è‡ªå·±ï¼Œå¾ˆç®€å•çš„å¤šè¿›ç¨‹/å¹¶è¡Œä¹Ÿå¯ä»¥æœ‰ä¸é”™çš„æ”¶ç›Šã€‚</p>

<p>æ¥ä¸‹æ¥æ˜¯ä¸€ä¸ªç®€é™‹çš„Pythonä¾‹å­ï¼Œä½¿ç”¨è’™ç‰¹å¡æ´›æ–¹æ³•è®¡ç®—Shapleyå€¼ã€‚</p>

<ul>
  <li>å•çº¿ç¨‹</li>
</ul>

<p>è§ä¸Šæ–‡ã€‚</p>

<ul>
  <li>å¤šçº¿ç¨‹</li>
</ul>

<p>è§ä¸Šæ–‡ã€‚</p>

<h3 id="è€—æ—¶å¯¹æ¯”">è€—æ—¶å¯¹æ¯”</h3>

<p>è§ä¸Šæ–‡ã€‚</p>
:ET