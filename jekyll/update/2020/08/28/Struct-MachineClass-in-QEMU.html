<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Struct MachineClass in QEMU | Percy</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Struct MachineClass in QEMU" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Auther: Percy Updated at 2020/8/28 Intro Before looking at the specific structure, let us have a glance on the use of this structure in the project. Begin with the main entrance file /softmmu/vl.c. graph LR A(&quot;func &#39;main&#39; in /softmmu/main.c&quot;) --&gt; B(&quot;func &#39;qemu_init&#39; in /softmmu/vl.c&quot;) B --&gt; C(&quot;func &#39;select_machine&#39; in /softmmu/vl.c&quot;) graph LR; A(&quot;func &#39;main&#39; in /softmmu/main.c&quot;) --&gt; B(&quot;func &#39;qemu_init&#39; in /softmmu/vl.c&quot;); B --&gt; C(&quot;func &#39;select_machine&#39; in /softmmu/vl.c&quot;); In func qemu_init, we will have two rounds of option parsing. In the first pass of option parsing, count the number of options and validate the legality of options. /* first pass of option parsing */ optind = 1; while (optind &lt; argc) { if (argv[optind][0] != &#39;-&#39;) { /* disk image */ optind++; } else { const QEMUOption *popt; popt = lookup_opt(argc, argv, &amp;optarg, &amp;optind); switch (popt-&gt;index) { case QEMU_OPTION_nouserconfig: userconfig = false; break; } } } And there is a speial case QEMU_OPTION_nouserconfig. It represents that if this argument exsits, the configuration process will use the corresponding config file. After this first pass, the second pass will start to fill the option list. case QEMU_OPTION_machine: olist = qemu_find_opts(&quot;machine&quot;); opts = qemu_opts_parse_noisily(olist, optarg, true); if (!opts) { exit(1); } break; ... machine_class = select_machine(); In func select_machine, get a single-linked list of MachineClass at first with function object_class_get_list. Walk this list to find the default value. Then get the machine_opts and extract the type property. Pass this string and previous list to func machine_parse. The target class will be given by the func find_machine through the comparasion of name property. (If hlep option attached, all supported classes which are sorted and default class will be shown. ) After got the target class, qemu can do initialization with it. With the analysis of the properties which is hold by MachineClass , the understanding of its role may be easier. The detailed descriptions are all added in the appendix. Appendix MachineClass Definition struct MachineClass { /*&lt; private &gt;*/ ObjectClass parent_class; /*&lt; public &gt;*/ const char *family; /* NULL iff @name identifies a standalone machtype */ char *name; const char *alias; /* another name */ const char *desc; const char *deprecation_reason; /* If set, the machine is marked as deprecated. The string should provide some clear information about what to use instead. */ /* provided func */ void (*init)(MachineState *state); void (*reset)(MachineState *state); void (*wakeup)(MachineState *state); void (*hot_add_cpu)(MachineState *state, const int64_t id, Error **errp); /** * @kvm_type: * Return the type of KVM corresponding to the kvm-type string option or * computed based on other criteria such as the host kernel capabilities. */ int (*kvm_type)(MachineState *machine, const char *arg); /** * @smp_parse: * The function pointer to hook different machine specific functions for * parsing &quot;smp-opts&quot; from QemuOpts to MachineState::CpuTopology and more * machine specific topology fields, such as smp_dies for PCMachine. */ void (*smp_parse)(MachineState *ms, QemuOpts *opts); BlockInterfaceType block_default_type; int units_per_default_bus; int max_cpus; /* maximum number of CPUs supported. Default: 1 */ int min_cpus; /* minimum number of CPUs supported. Default: 1 */ int default_cpus; /* number of CPUs instantiated if none are specified. Default: 1 */ unsigned int no_serial:1, no_parallel:1, no_floppy:1, no_cdrom:1, no_sdcard:1, pci_allow_0_address:1, legacy_fw_cfg_order:1; bool is_default; /* If true QEMU will use this machine by default if no &#39;-M&#39; option is given. */ const char *default_machine_opts; const char *default_boot_order; const char *default_display; GPtrArray *compat_props; const char *hw_version; /* Value of QEMU_VERSION when the machine was added to QEMU. */ ram_addr_t default_ram_size; const char *default_cpu_type; /* specifies default CPU_TYPE, which will be used for parsing target specific features and for creating CPUs if CPU name wasn&#39;t provided explicitly at CLI */ bool default_kernel_irqchip_split; bool option_rom_has_mr; bool rom_file_has_mr; int minimum_page_bits; /* If non-zero, the board promises never to create a CPU with a page size smaller than this */ bool has_hotpluggable_cpus; /* If true, board supports CPUs creation with -device/device_add. */ bool ignore_memory_transaction_failures; /* If this is flag is true then the CPU will ignore memory transaction failures which should cause the CPU to take an exception due to an access to an unassigned physical address */ int numa_mem_align_shift; const char **valid_cpu_types; strList *allowed_dynamic_sysbus_devices; bool auto_enable_numa_with_memhp; bool auto_enable_numa_with_memdev; void (*numa_auto_assign_ram)(MachineClass *mc, NodeInfo *nodes, int nb_nodes, ram_addr_t size); bool ignore_boot_device_suffixes; bool smbus_no_migration_support; bool nvdimm_supported; bool numa_mem_supported; /* true if &#39;--numa node.mem&#39; option is supported */ bool auto_enable_numa; const char *default_ram_id; /* Specifies inital RAM MemoryRegion name */ /** * @hotplug_allowed: * If the hook is provided, then it&#39;ll be called for each device * hotplug to check whether the device hotplug is allowed. Return * true to grant allowance or false to reject the hotplug. When * false is returned, an error must be set to show the reason of * the rejection. If the hook is not provided, all hotplug will be * allowed. */ HotplugHandler *(*get_hotplug_handler)(MachineState *machine, DeviceState *dev); /** * @get_hotplug_handler: this function is called during bus-less * device hotplug. If defined it returns pointer to an instance * of HotplugHandler object, which handles hotplug operation * for a given @dev. It may return NULL if @dev doesn&#39;t require * any actions to be performed by hotplug handler. */ bool (*hotplug_allowed)(MachineState *state, DeviceState *dev, Error **errp); /** * @cpu_index_to_instance_props: * used to provide @cpu_index to socket/core/thread number mapping, allowing * legacy code to perform maping from cpu_index to topology properties * Returns: tuple of socket/core/thread ids given cpu_index belongs to. * used to provide @cpu_index to socket number mapping, allowing * a machine to group CPU threads belonging to the same socket/package * Returns: socket number given cpu_index belongs to. */ CpuInstanceProperties (*cpu_index_to_instance_props)(MachineState *machine, unsigned cpu_index); /** * @possible_cpu_arch_ids: * Returns an array of @CPUArchId architecture-dependent CPU IDs * which includes CPU IDs for present and possible to hotplug CPUs. * Caller is responsible for freeing returned list. */ const CPUArchIdList *(*possible_cpu_arch_ids)(MachineState *machine); /** * @get_default_cpu_node_id: * returns default board specific node_id value for CPU slot specified by * index @idx in @ms-&gt;possible_cpus[] */ int64_t (*get_default_cpu_node_id)(const MachineState *ms, int idx); /** * @fixup_ram_size * Amends user provided ram size (with -m option) using machine specific * algorithm. To be used by old machine types for compat purposes only. */ ram_addr_t (*fixup_ram_size)(ram_addr_t size); }; Glossary bus-less device: [Waiting to be added] numa: Non-uniform memory access kvm: Kernel-based Virtual Machine smp: Symmetric multiprocessing" />
<meta property="og:description" content="Auther: Percy Updated at 2020/8/28 Intro Before looking at the specific structure, let us have a glance on the use of this structure in the project. Begin with the main entrance file /softmmu/vl.c. graph LR A(&quot;func &#39;main&#39; in /softmmu/main.c&quot;) --&gt; B(&quot;func &#39;qemu_init&#39; in /softmmu/vl.c&quot;) B --&gt; C(&quot;func &#39;select_machine&#39; in /softmmu/vl.c&quot;) graph LR; A(&quot;func &#39;main&#39; in /softmmu/main.c&quot;) --&gt; B(&quot;func &#39;qemu_init&#39; in /softmmu/vl.c&quot;); B --&gt; C(&quot;func &#39;select_machine&#39; in /softmmu/vl.c&quot;); In func qemu_init, we will have two rounds of option parsing. In the first pass of option parsing, count the number of options and validate the legality of options. /* first pass of option parsing */ optind = 1; while (optind &lt; argc) { if (argv[optind][0] != &#39;-&#39;) { /* disk image */ optind++; } else { const QEMUOption *popt; popt = lookup_opt(argc, argv, &amp;optarg, &amp;optind); switch (popt-&gt;index) { case QEMU_OPTION_nouserconfig: userconfig = false; break; } } } And there is a speial case QEMU_OPTION_nouserconfig. It represents that if this argument exsits, the configuration process will use the corresponding config file. After this first pass, the second pass will start to fill the option list. case QEMU_OPTION_machine: olist = qemu_find_opts(&quot;machine&quot;); opts = qemu_opts_parse_noisily(olist, optarg, true); if (!opts) { exit(1); } break; ... machine_class = select_machine(); In func select_machine, get a single-linked list of MachineClass at first with function object_class_get_list. Walk this list to find the default value. Then get the machine_opts and extract the type property. Pass this string and previous list to func machine_parse. The target class will be given by the func find_machine through the comparasion of name property. (If hlep option attached, all supported classes which are sorted and default class will be shown. ) After got the target class, qemu can do initialization with it. With the analysis of the properties which is hold by MachineClass , the understanding of its role may be easier. The detailed descriptions are all added in the appendix. Appendix MachineClass Definition struct MachineClass { /*&lt; private &gt;*/ ObjectClass parent_class; /*&lt; public &gt;*/ const char *family; /* NULL iff @name identifies a standalone machtype */ char *name; const char *alias; /* another name */ const char *desc; const char *deprecation_reason; /* If set, the machine is marked as deprecated. The string should provide some clear information about what to use instead. */ /* provided func */ void (*init)(MachineState *state); void (*reset)(MachineState *state); void (*wakeup)(MachineState *state); void (*hot_add_cpu)(MachineState *state, const int64_t id, Error **errp); /** * @kvm_type: * Return the type of KVM corresponding to the kvm-type string option or * computed based on other criteria such as the host kernel capabilities. */ int (*kvm_type)(MachineState *machine, const char *arg); /** * @smp_parse: * The function pointer to hook different machine specific functions for * parsing &quot;smp-opts&quot; from QemuOpts to MachineState::CpuTopology and more * machine specific topology fields, such as smp_dies for PCMachine. */ void (*smp_parse)(MachineState *ms, QemuOpts *opts); BlockInterfaceType block_default_type; int units_per_default_bus; int max_cpus; /* maximum number of CPUs supported. Default: 1 */ int min_cpus; /* minimum number of CPUs supported. Default: 1 */ int default_cpus; /* number of CPUs instantiated if none are specified. Default: 1 */ unsigned int no_serial:1, no_parallel:1, no_floppy:1, no_cdrom:1, no_sdcard:1, pci_allow_0_address:1, legacy_fw_cfg_order:1; bool is_default; /* If true QEMU will use this machine by default if no &#39;-M&#39; option is given. */ const char *default_machine_opts; const char *default_boot_order; const char *default_display; GPtrArray *compat_props; const char *hw_version; /* Value of QEMU_VERSION when the machine was added to QEMU. */ ram_addr_t default_ram_size; const char *default_cpu_type; /* specifies default CPU_TYPE, which will be used for parsing target specific features and for creating CPUs if CPU name wasn&#39;t provided explicitly at CLI */ bool default_kernel_irqchip_split; bool option_rom_has_mr; bool rom_file_has_mr; int minimum_page_bits; /* If non-zero, the board promises never to create a CPU with a page size smaller than this */ bool has_hotpluggable_cpus; /* If true, board supports CPUs creation with -device/device_add. */ bool ignore_memory_transaction_failures; /* If this is flag is true then the CPU will ignore memory transaction failures which should cause the CPU to take an exception due to an access to an unassigned physical address */ int numa_mem_align_shift; const char **valid_cpu_types; strList *allowed_dynamic_sysbus_devices; bool auto_enable_numa_with_memhp; bool auto_enable_numa_with_memdev; void (*numa_auto_assign_ram)(MachineClass *mc, NodeInfo *nodes, int nb_nodes, ram_addr_t size); bool ignore_boot_device_suffixes; bool smbus_no_migration_support; bool nvdimm_supported; bool numa_mem_supported; /* true if &#39;--numa node.mem&#39; option is supported */ bool auto_enable_numa; const char *default_ram_id; /* Specifies inital RAM MemoryRegion name */ /** * @hotplug_allowed: * If the hook is provided, then it&#39;ll be called for each device * hotplug to check whether the device hotplug is allowed. Return * true to grant allowance or false to reject the hotplug. When * false is returned, an error must be set to show the reason of * the rejection. If the hook is not provided, all hotplug will be * allowed. */ HotplugHandler *(*get_hotplug_handler)(MachineState *machine, DeviceState *dev); /** * @get_hotplug_handler: this function is called during bus-less * device hotplug. If defined it returns pointer to an instance * of HotplugHandler object, which handles hotplug operation * for a given @dev. It may return NULL if @dev doesn&#39;t require * any actions to be performed by hotplug handler. */ bool (*hotplug_allowed)(MachineState *state, DeviceState *dev, Error **errp); /** * @cpu_index_to_instance_props: * used to provide @cpu_index to socket/core/thread number mapping, allowing * legacy code to perform maping from cpu_index to topology properties * Returns: tuple of socket/core/thread ids given cpu_index belongs to. * used to provide @cpu_index to socket number mapping, allowing * a machine to group CPU threads belonging to the same socket/package * Returns: socket number given cpu_index belongs to. */ CpuInstanceProperties (*cpu_index_to_instance_props)(MachineState *machine, unsigned cpu_index); /** * @possible_cpu_arch_ids: * Returns an array of @CPUArchId architecture-dependent CPU IDs * which includes CPU IDs for present and possible to hotplug CPUs. * Caller is responsible for freeing returned list. */ const CPUArchIdList *(*possible_cpu_arch_ids)(MachineState *machine); /** * @get_default_cpu_node_id: * returns default board specific node_id value for CPU slot specified by * index @idx in @ms-&gt;possible_cpus[] */ int64_t (*get_default_cpu_node_id)(const MachineState *ms, int idx); /** * @fixup_ram_size * Amends user provided ram size (with -m option) using machine specific * algorithm. To be used by old machine types for compat purposes only. */ ram_addr_t (*fixup_ram_size)(ram_addr_t size); }; Glossary bus-less device: [Waiting to be added] numa: Non-uniform memory access kvm: Kernel-based Virtual Machine smp: Symmetric multiprocessing" />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2020/08/28/Struct-MachineClass-in-QEMU.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2020/08/28/Struct-MachineClass-in-QEMU.html" />
<meta property="og:site_name" content="Percy" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-08-28T20:00:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/jekyll/update/2020/08/28/Struct-MachineClass-in-QEMU.html","headline":"Struct MachineClass in QEMU","dateModified":"2020-08-28T20:00:00+08:00","datePublished":"2020-08-28T20:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2020/08/28/Struct-MachineClass-in-QEMU.html"},"description":"Auther: Percy Updated at 2020/8/28 Intro Before looking at the specific structure, let us have a glance on the use of this structure in the project. Begin with the main entrance file /softmmu/vl.c. graph LR A(&quot;func &#39;main&#39; in /softmmu/main.c&quot;) --&gt; B(&quot;func &#39;qemu_init&#39; in /softmmu/vl.c&quot;) B --&gt; C(&quot;func &#39;select_machine&#39; in /softmmu/vl.c&quot;) graph LR; A(&quot;func &#39;main&#39; in /softmmu/main.c&quot;) --&gt; B(&quot;func &#39;qemu_init&#39; in /softmmu/vl.c&quot;); B --&gt; C(&quot;func &#39;select_machine&#39; in /softmmu/vl.c&quot;); In func qemu_init, we will have two rounds of option parsing. In the first pass of option parsing, count the number of options and validate the legality of options. /* first pass of option parsing */ optind = 1; while (optind &lt; argc) { if (argv[optind][0] != &#39;-&#39;) { /* disk image */ optind++; } else { const QEMUOption *popt; popt = lookup_opt(argc, argv, &amp;optarg, &amp;optind); switch (popt-&gt;index) { case QEMU_OPTION_nouserconfig: userconfig = false; break; } } } And there is a speial case QEMU_OPTION_nouserconfig. It represents that if this argument exsits, the configuration process will use the corresponding config file. After this first pass, the second pass will start to fill the option list. case QEMU_OPTION_machine: olist = qemu_find_opts(&quot;machine&quot;); opts = qemu_opts_parse_noisily(olist, optarg, true); if (!opts) { exit(1); } break; ... machine_class = select_machine(); In func select_machine, get a single-linked list of MachineClass at first with function object_class_get_list. Walk this list to find the default value. Then get the machine_opts and extract the type property. Pass this string and previous list to func machine_parse. The target class will be given by the func find_machine through the comparasion of name property. (If hlep option attached, all supported classes which are sorted and default class will be shown. ) After got the target class, qemu can do initialization with it. With the analysis of the properties which is hold by MachineClass , the understanding of its role may be easier. The detailed descriptions are all added in the appendix. Appendix MachineClass Definition struct MachineClass { /*&lt; private &gt;*/ ObjectClass parent_class; /*&lt; public &gt;*/ const char *family; /* NULL iff @name identifies a standalone machtype */ char *name; const char *alias; /* another name */ const char *desc; const char *deprecation_reason; /* If set, the machine is marked as deprecated. The string should provide some clear information about what to use instead. */ /* provided func */ void (*init)(MachineState *state); void (*reset)(MachineState *state); void (*wakeup)(MachineState *state); void (*hot_add_cpu)(MachineState *state, const int64_t id, Error **errp); /** * @kvm_type: * Return the type of KVM corresponding to the kvm-type string option or * computed based on other criteria such as the host kernel capabilities. */ int (*kvm_type)(MachineState *machine, const char *arg); /** * @smp_parse: * The function pointer to hook different machine specific functions for * parsing &quot;smp-opts&quot; from QemuOpts to MachineState::CpuTopology and more * machine specific topology fields, such as smp_dies for PCMachine. */ void (*smp_parse)(MachineState *ms, QemuOpts *opts); BlockInterfaceType block_default_type; int units_per_default_bus; int max_cpus; /* maximum number of CPUs supported. Default: 1 */ int min_cpus; /* minimum number of CPUs supported. Default: 1 */ int default_cpus; /* number of CPUs instantiated if none are specified. Default: 1 */ unsigned int no_serial:1, no_parallel:1, no_floppy:1, no_cdrom:1, no_sdcard:1, pci_allow_0_address:1, legacy_fw_cfg_order:1; bool is_default; /* If true QEMU will use this machine by default if no &#39;-M&#39; option is given. */ const char *default_machine_opts; const char *default_boot_order; const char *default_display; GPtrArray *compat_props; const char *hw_version; /* Value of QEMU_VERSION when the machine was added to QEMU. */ ram_addr_t default_ram_size; const char *default_cpu_type; /* specifies default CPU_TYPE, which will be used for parsing target specific features and for creating CPUs if CPU name wasn&#39;t provided explicitly at CLI */ bool default_kernel_irqchip_split; bool option_rom_has_mr; bool rom_file_has_mr; int minimum_page_bits; /* If non-zero, the board promises never to create a CPU with a page size smaller than this */ bool has_hotpluggable_cpus; /* If true, board supports CPUs creation with -device/device_add. */ bool ignore_memory_transaction_failures; /* If this is flag is true then the CPU will ignore memory transaction failures which should cause the CPU to take an exception due to an access to an unassigned physical address */ int numa_mem_align_shift; const char **valid_cpu_types; strList *allowed_dynamic_sysbus_devices; bool auto_enable_numa_with_memhp; bool auto_enable_numa_with_memdev; void (*numa_auto_assign_ram)(MachineClass *mc, NodeInfo *nodes, int nb_nodes, ram_addr_t size); bool ignore_boot_device_suffixes; bool smbus_no_migration_support; bool nvdimm_supported; bool numa_mem_supported; /* true if &#39;--numa node.mem&#39; option is supported */ bool auto_enable_numa; const char *default_ram_id; /* Specifies inital RAM MemoryRegion name */ /** * @hotplug_allowed: * If the hook is provided, then it&#39;ll be called for each device * hotplug to check whether the device hotplug is allowed. Return * true to grant allowance or false to reject the hotplug. When * false is returned, an error must be set to show the reason of * the rejection. If the hook is not provided, all hotplug will be * allowed. */ HotplugHandler *(*get_hotplug_handler)(MachineState *machine, DeviceState *dev); /** * @get_hotplug_handler: this function is called during bus-less * device hotplug. If defined it returns pointer to an instance * of HotplugHandler object, which handles hotplug operation * for a given @dev. It may return NULL if @dev doesn&#39;t require * any actions to be performed by hotplug handler. */ bool (*hotplug_allowed)(MachineState *state, DeviceState *dev, Error **errp); /** * @cpu_index_to_instance_props: * used to provide @cpu_index to socket/core/thread number mapping, allowing * legacy code to perform maping from cpu_index to topology properties * Returns: tuple of socket/core/thread ids given cpu_index belongs to. * used to provide @cpu_index to socket number mapping, allowing * a machine to group CPU threads belonging to the same socket/package * Returns: socket number given cpu_index belongs to. */ CpuInstanceProperties (*cpu_index_to_instance_props)(MachineState *machine, unsigned cpu_index); /** * @possible_cpu_arch_ids: * Returns an array of @CPUArchId architecture-dependent CPU IDs * which includes CPU IDs for present and possible to hotplug CPUs. * Caller is responsible for freeing returned list. */ const CPUArchIdList *(*possible_cpu_arch_ids)(MachineState *machine); /** * @get_default_cpu_node_id: * returns default board specific node_id value for CPU slot specified by * index @idx in @ms-&gt;possible_cpus[] */ int64_t (*get_default_cpu_node_id)(const MachineState *ms, int idx); /** * @fixup_ram_size * Amends user provided ram size (with -m option) using machine specific * algorithm. To be used by old machine types for compat purposes only. */ ram_addr_t (*fixup_ram_size)(ram_addr_t size); }; Glossary bus-less device: [Waiting to be added] numa: Non-uniform memory access kvm: Kernel-based Virtual Machine smp: Symmetric multiprocessing","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Percy" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Percy</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Struct MachineClass in QEMU</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-08-28T20:00:00+08:00" itemprop="datePublished">Aug 28, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <blockquote>
  <p>Auther: Percy</p>

  <p>Updated at 2020/8/28</p>
</blockquote>

<h2 id="intro">Intro</h2>

<p>Before looking at the specific structure, let us have a glance on the use of this structure in the project.</p>

<p>Begin with the main entrance file <a href="https://github.com/qemu/qemu/blob/master/softmmu/vl.c">/softmmu/vl.c</a>.</p>

<pre><code class="language-mermaid">graph LR
A("func 'main' in /softmmu/main.c") --&gt; B("func 'qemu_init' in /softmmu/vl.c")
B --&gt; C("func 'select_machine' in /softmmu/vl.c")
</code></pre>

<script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.js"></script>
<div class="mermaid">
graph LR;
    A("func 'main' in /softmmu/main.c") --&gt; B("func 'qemu_init' in /softmmu/vl.c");
    B --&gt; C("func 'select_machine' in /softmmu/vl.c");
</div>

<p>In func <code class="language-plaintext highlighter-rouge">qemu_init</code>, we will have two rounds of option parsing. In the first pass of option parsing, count the number of options and validate the legality of options.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/* first pass of option parsing */</span>
    <span class="n">optind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">optind</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">optind</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'-'</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* disk image */</span>
            <span class="n">optind</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">const</span> <span class="n">QEMUOption</span> <span class="o">*</span><span class="n">popt</span><span class="p">;</span>

            <span class="n">popt</span> <span class="o">=</span> <span class="n">lookup_opt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optarg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optind</span><span class="p">);</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">popt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">QEMU_OPTION_nouserconfig</span><span class="p">:</span>
                <span class="n">userconfig</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>And there is a speial case <code class="language-plaintext highlighter-rouge">QEMU_OPTION_nouserconfig</code>. It represents that if this argument exsits, the configuration process will use the corresponding config file. After this first pass, the second pass will start to fill the option list.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">case</span> <span class="n">QEMU_OPTION_machine</span><span class="p">:</span>
                <span class="n">olist</span> <span class="o">=</span> <span class="n">qemu_find_opts</span><span class="p">(</span><span class="s">"machine"</span><span class="p">);</span>
                <span class="n">opts</span> <span class="o">=</span> <span class="n">qemu_opts_parse_noisily</span><span class="p">(</span><span class="n">olist</span><span class="p">,</span> <span class="n">optarg</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
<span class="p">...</span>
    <span class="n">machine_class</span> <span class="o">=</span> <span class="n">select_machine</span><span class="p">();</span>
</code></pre></div></div>

<p>In func <code class="language-plaintext highlighter-rouge">select_machine</code>,  get a single-linked list of <code class="language-plaintext highlighter-rouge">MachineClass</code> at first with function <code class="language-plaintext highlighter-rouge">object_class_get_list</code>.  Walk this list to find the default value. Then get the machine_opts and extract the <code class="language-plaintext highlighter-rouge">type</code> property. Pass this string and previous list to func <code class="language-plaintext highlighter-rouge">machine_parse</code>. The target class will be given by the func <code class="language-plaintext highlighter-rouge">find_machine</code>  through the comparasion of name property. (If hlep option attached, all supported classes which are sorted and default class will be shown. )</p>

<hr />

<p>After got the target class, qemu can do initialization with it. With the analysis of the properties which is hold by <code class="language-plaintext highlighter-rouge">MachineClass </code>, the understanding of its role may be easier. The detailed descriptions are all added in the appendix.</p>

<h2 id="appendix">Appendix</h2>

<h3 id="machineclass-definition">MachineClass Definition</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MachineClass</span> <span class="p">{</span>
    <span class="cm">/*&lt; private &gt;*/</span>
    <span class="n">ObjectClass</span> <span class="n">parent_class</span><span class="p">;</span>
    <span class="cm">/*&lt; public &gt;*/</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">family</span><span class="p">;</span> <span class="cm">/* NULL iff @name identifies a standalone machtype */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alias</span><span class="p">;</span> <span class="cm">/* another name */</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">deprecation_reason</span><span class="p">;</span> <span class="cm">/* If set, the machine is marked as deprecated. The
    string should provide some clear information about what to use instead. */</span>

    <span class="cm">/* provided func */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wakeup</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hot_add_cpu</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">id</span><span class="p">,</span> <span class="n">Error</span> <span class="o">**</span><span class="n">errp</span><span class="p">);</span>
<span class="cm">/**
 *    @kvm_type:
 *    Return the type of KVM corresponding to the kvm-type string option or
 *    computed based on other criteria such as the host kernel capabilities.
 */</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">kvm_type</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
    
<span class="cm">/**
 *    @smp_parse:
 *    The function pointer to hook different machine specific functions for
 *    parsing "smp-opts" from QemuOpts to MachineState::CpuTopology and more
 *    machine specific topology fields, such as smp_dies for PCMachine.
 */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">smp_parse</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="n">QemuOpts</span> <span class="o">*</span><span class="n">opts</span><span class="p">);</span>

    <span class="n">BlockInterfaceType</span> <span class="n">block_default_type</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">units_per_default_bus</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">;</span> <span class="cm">/* maximum number of CPUs supported. Default: 1 */</span>
    <span class="kt">int</span> <span class="n">min_cpus</span><span class="p">;</span> <span class="cm">/* minimum number of CPUs supported. Default: 1 */</span>
    <span class="kt">int</span> <span class="n">default_cpus</span><span class="p">;</span> <span class="cm">/* number of CPUs instantiated if none are specified. Default: 1 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_serial</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">no_parallel:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">no_floppy:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">no_cdrom:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">no_sdcard:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">pci_allow_0_address:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">legacy_fw_cfg_order:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">is_default</span><span class="p">;</span> <span class="cm">/* If true QEMU will use this machine by default if no '-M' option is given. */</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_machine_opts</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_boot_order</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_display</span><span class="p">;</span>
    <span class="n">GPtrArray</span> <span class="o">*</span><span class="n">compat_props</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hw_version</span><span class="p">;</span> <span class="cm">/* Value of QEMU_VERSION when the machine was added to QEMU. */</span>
    <span class="n">ram_addr_t</span> <span class="n">default_ram_size</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_cpu_type</span><span class="p">;</span> <span class="cm">/* specifies default CPU_TYPE, which will be used for parsing target specific features and for creating CPUs if CPU name wasn't provided explicitly at CLI */</span>
    <span class="n">bool</span> <span class="n">default_kernel_irqchip_split</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">option_rom_has_mr</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">rom_file_has_mr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minimum_page_bits</span><span class="p">;</span> <span class="cm">/* If non-zero, the board promises never to create a CPU with a page size smaller than this */</span>
    <span class="n">bool</span> <span class="n">has_hotpluggable_cpus</span><span class="p">;</span> <span class="cm">/* If true, board supports CPUs creation with -device/device_add. */</span>
    <span class="n">bool</span> <span class="n">ignore_memory_transaction_failures</span><span class="p">;</span> <span class="cm">/* If this is flag is true then the CPU will ignore memory transaction failures which should cause the CPU to take an exception due to an access to an unassigned physical address */</span>
    <span class="kt">int</span> <span class="n">numa_mem_align_shift</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">valid_cpu_types</span><span class="p">;</span>
    <span class="n">strList</span> <span class="o">*</span><span class="n">allowed_dynamic_sysbus_devices</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">auto_enable_numa_with_memhp</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">auto_enable_numa_with_memdev</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">numa_auto_assign_ram</span><span class="p">)(</span><span class="n">MachineClass</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span> <span class="n">NodeInfo</span> <span class="o">*</span><span class="n">nodes</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">nb_nodes</span><span class="p">,</span> <span class="n">ram_addr_t</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">bool</span> <span class="n">ignore_boot_device_suffixes</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">smbus_no_migration_support</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">nvdimm_supported</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">numa_mem_supported</span><span class="p">;</span> <span class="cm">/* true if '--numa node.mem' option is supported  */</span>
    <span class="n">bool</span> <span class="n">auto_enable_numa</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">default_ram_id</span><span class="p">;</span> <span class="cm">/* Specifies inital RAM MemoryRegion name */</span>

<span class="cm">/**
 * 	  @hotplug_allowed:
 *    If the hook is provided, then it'll be called for each device
 *    hotplug to check whether the device hotplug is allowed.  Return
 *    true to grant allowance or false to reject the hotplug.  When
 *    false is returned, an error must be set to show the reason of
 *    the rejection.  If the hook is not provided, all hotplug will be
 *    allowed.
 */</span>
    <span class="n">HotplugHandler</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_hotplug_handler</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span>
                                           <span class="n">DeviceState</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
    
<span class="cm">/**
 *    @get_hotplug_handler: this function is called during bus-less
 *    device hotplug. If defined it returns pointer to an instance
 *    of HotplugHandler object, which handles hotplug operation
 *    for a given @dev. It may return NULL if @dev doesn't require
 *    any actions to be performed by hotplug handler.
 */</span>
    <span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">hotplug_allowed</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">DeviceState</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                            <span class="n">Error</span> <span class="o">**</span><span class="n">errp</span><span class="p">);</span>
<span class="cm">/**
 *    @cpu_index_to_instance_props:
 *    used to provide @cpu_index to socket/core/thread number mapping, allowing
 *    legacy code to perform maping from cpu_index to topology properties
 *    Returns: tuple of socket/core/thread ids given cpu_index belongs to.
 *    used to provide @cpu_index to socket number mapping, allowing
 *    a machine to group CPU threads belonging to the same socket/package
 *    Returns: socket number given cpu_index belongs to.
 */</span>
    <span class="n">CpuInstanceProperties</span> <span class="p">(</span><span class="o">*</span><span class="n">cpu_index_to_instance_props</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span>
                                                         <span class="kt">unsigned</span> <span class="n">cpu_index</span><span class="p">);</span>
    
<span class="cm">/**
 *    @possible_cpu_arch_ids:
 *    Returns an array of @CPUArchId architecture-dependent CPU IDs
 *    which includes CPU IDs for present and possible to hotplug CPUs.
 *    Caller is responsible for freeing returned list.
 */</span>
    <span class="k">const</span> <span class="n">CPUArchIdList</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">possible_cpu_arch_ids</span><span class="p">)(</span><span class="n">MachineState</span> <span class="o">*</span><span class="n">machine</span><span class="p">);</span>
    
<span class="cm">/**
 *    @get_default_cpu_node_id:
 *    returns default board specific node_id value for CPU slot specified by
 *    index @idx in @ms-&gt;possible_cpus[]
 */</span>
    <span class="kt">int64_t</span> <span class="p">(</span><span class="o">*</span><span class="n">get_default_cpu_node_id</span><span class="p">)(</span><span class="k">const</span> <span class="n">MachineState</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
    
<span class="cm">/**
 *    @fixup_ram_size
 *    Amends user provided ram size (with -m option) using machine specific 
 *    algorithm. To be used by old machine types for compat purposes only.
 */</span>  
    <span class="n">ram_addr_t</span> <span class="p">(</span><span class="o">*</span><span class="n">fixup_ram_size</span><span class="p">)(</span><span class="n">ram_addr_t</span> <span class="n">size</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="glossary">Glossary</h3>

<ul>
  <li>bus-less device: [Waiting to be added]</li>
  <li>numa: Non-uniform memory access</li>
  <li>kvm: Kernel-based Virtual Machine</li>
  <li>smp: Symmetric multiprocessing</li>
</ul>

  </div><a class="u-url" href="/jekyll/update/2020/08/28/Struct-MachineClass-in-QEMU.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Percy</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Percy</li><li><a class="u-email" href="mailto:xhc_0817@foxmail.com">xhc_0817@foxmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/haochengxia"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">haochengxia</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Latter equals never.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
