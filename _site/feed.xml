<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Percy - Latter equals never</title>
    <description>Null.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Speed up Sampling Based Calculation</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Auther: Percy&lt;/p&gt;

  &lt;p&gt;Updated at 2020/12/19&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;body&quot;&gt;Body&lt;/h3&gt;

&lt;p&gt;To my best knowledge, the most of the sampling based algorithm can be simply run in multi-process/parallel as we can divide the samples into parts.&lt;/p&gt;

&lt;p&gt;This simple blog aims at reminding myself that we can benefit a lot with naive multiprocessing.&lt;/p&gt;

&lt;p&gt;The next part is a crude example on the calculation of Shpaley value based on Monte Carlo in Python.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;single processing&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from tqdm import trange
import numpy as np


def eval_shap(x_train, y_train, x_test, y_test):    
    for t in trange(M):
		    ''' calculate Shapley value with Monte Carlo
		    ...
		    '''
    return np.asarray(sv) # type(sv) -&amp;gt; list
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;multiprocessing&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from tqdm import trange
from multiprocessing import Pool
from functools import partial
import numpy as np

procs_num = 5


def sub_task(x_train, y_train, x_test, y_test, ID):
    for t in trange(M / procs_num):
		    ''' calculate Shapley value with Monte Carlo
		    ...
		    '''
    # print('task of proc' + str(ID) + ' completed!')
    return sv # type(sv) -&amp;gt; list


def eval_shap_multi_proc(x_train, y_train, x_test, y_test):
    proc_ids = [i for i in range(procs_num)]

    pool = Pool()
    func = partial(sub_task, x_train, y_train, x_test, y_test)
    ret = pool.map(func, proc_ids)
    pool.close()
    pool.join()
    ret_arr = np.asarray(ret)
    return np.sum(ret_arr, axis=0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;time-cost-comparison&quot;&gt;Time Cost Comparison&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Test on MacBook Pro (16-inch, 2019)&lt;/p&gt;

  &lt;p&gt;Intel Core i7 - 6 cores 2.6GHz&lt;/p&gt;

  &lt;p&gt;16 GB 2667MHz DDR4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;# multi
100%|██████████| 6000/6000 [01:23&amp;lt;00:00, 71.56it/s]
100%|██████████| 6000/6000 [01:24&amp;lt;00:00, 70.99it/s]
100%|██████████| 6000/6000 [01:26&amp;lt;00:00, 69.50it/s]
100%|██████████| 6000/6000 [01:26&amp;lt;00:00, 69.49it/s]
100%|██████████| 6000/6000 [01:26&amp;lt;00:00, 69.28it/s]

# single
100%|██████████| 30000/30000 [06:31&amp;lt;00:00, 76.65it/s]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With multiprocessing, the time cost becomes a quarter of the original.&lt;/p&gt;

&lt;p&gt;And the result is certainly similar. (They use different permutations here!)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# multi
[1172.625       843.54166667 1308.43333333 1159.20833333 1560.875
 1327.68333333  991.15        762.61666667 1379.56666667  520.84166667
  994.625       906.79166667 1050.1         805.875       987.28333333
 1025.06666667  923.14166667 1115.40833333  995.43333333  760.525
  916.14166667  687.3         892.63333333  912.675      1051.75833333
 1041.11666667 1010.83333333  718.66666667  799.10833333  960.50833333]
 
# single
[1155.29166667  863.43333333 1308.04166667 1189.74166667 1561.99166667
 1379.025       970.75        798.75       1313.13333333  522.35833333
  985.5         868.38333333 1056.575       757.6        1018.25833333
 1027.33333333  936.275      1033.80833333  991.68333333  789.7
  886.95        729.475       889.26666667  908.63333333 1066.10833333
 1056.36666667 1049.075       700.33333333  822.53333333  945.99166667]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;chinese-version&quot;&gt;Chinese Version&lt;/h2&gt;

&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;

&lt;p&gt;在我的认知中，大多数基于采样的算法都可以被很简单地多进程处理/并行化，因为采到的样本可以被分成多个部分。&lt;/p&gt;

&lt;p&gt;这篇简单的博文用于提醒我自己，很简单的多进程/并行也可以有不错的收益。&lt;/p&gt;

&lt;p&gt;接下来是一个简陋的Python例子，使用蒙特卡洛方法计算Shapley值。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;见上文。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;见上文。&lt;/p&gt;

&lt;h3 id=&quot;耗时对比&quot;&gt;耗时对比&lt;/h3&gt;

&lt;p&gt;见上文。&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Dec 2020 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/jekyll/update/2020/12/19/Speed-up-Sampling-Based-Calculation/</link>
        <guid isPermaLink="true">http://localhost:4000/jekyll/update/2020/12/19/Speed-up-Sampling-Based-Calculation/</guid>
      </item>
    
      <item>
        <title>Begin with QEMU educational PCI device </title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Author: Percy&lt;/p&gt;

  &lt;p&gt;Updated at 2020/09/07&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;0-introduction-of-pci-structure&quot;&gt;0 Introduction of PCI structure&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;This part mainly quoted from wiki &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6%E4%BA%92%E8%BF%9E%E6%A0%87%E5%87%86&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PCI represents Peripheral Component Interconnect.&lt;/p&gt;

&lt;h3 id=&quot;01-main-concepts&quot;&gt;0.1 Main Concepts&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;PCI device: A device that conforms to the PCI bus standard is called a PCI device, and the PCI bus architecture can contain multiple PCI devices.&lt;/li&gt;
  &lt;li&gt;PCI bus: There can be multiple in the system, similar to a tree structure for expansion. Each PCI bus can connect multiple PCI devices. The upper and lower PCI bus interconnections are realized through the bridge.&lt;/li&gt;
  &lt;li&gt;PCI bridge: Connect the link between the PCI bus.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;------------------------------------------------------------------ Host bus
	|
	| HOST/PCI bridge
	|				| PCI device1    | PCI device2
------------------------------------------------------------------ PCI BUS1
		|
		| PCI/PCI bridge
		|					| PCI device3
------------------------------------------------------------------ PCI BUS2

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Other:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;PCI is a &lt;strong&gt;parallel bus&lt;/strong&gt;. In one clock cycle, 32 bits (later expanded to 64) are simultaneously transmitted. Address and data are respectively transmitted once in a clock cycle according to the protocol.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The PCI address space is &lt;strong&gt;isolated&lt;/strong&gt; from the processor address space. The processor bus and PCI bus work at their respective clock frequencies and do not interfere with each other. (with the buffers in host bridge)&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;The “Host Bridge” is what connects the tree of PCI busses (which are internally connected with PCI-to-PCI Bridges) to the rest of the system.  Usually the processor(s) and memory are on the “other” side of the Host Bridge.&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;02-pci-device-intro&quot;&gt;0.2 PCI device intro&lt;/h3&gt;

&lt;p&gt;Every PCI device has a configuration space and several address space.&lt;/p&gt;

&lt;h4 id=&quot;021-pci-configuration-space&quot;&gt;0.2.1 PCI configuration space&lt;/h4&gt;

&lt;p&gt;In order to implements hot-plugin, configuration space whose size is 256 bytes totally is neccessary.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Access method&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Write IO ports CFCh and CF8h. Only the first 256 bytes of PCI/PCIe devices can be accessed. As mentioned above, the whole configuration space size of PCI device is 256 bytes.&lt;/p&gt;

&lt;p&gt;There are two types configuration space, agent and bridge.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Agent configuration space&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	DW |    Byte3    |    Byte2    |    Byte1    |     Byte0     | Addr
		---+---------------------------------------------------------+-----
		 0 | 　　　　Device ID 　　　　| 　　　　Vendor ID 　　　　　|　00
		---+---------------------------------------------------------+-----
		 1 | 　　　　　Status　　　　　| 　　　　 Command　　　　　　|　04
		---+---------------------------------------------------------+-----
		 2 | 　　　　　　　Class Code　　　　　　　　|　Revision ID　|　08
		---+---------------------------------------------------------+-----
		 3 | 　　BIST　　| Header Type | Latency Timer | Cache Line  |　0C
		---+---------------------------------------------------------+-----
		 4 | 　　　　　　　　　　Base Address 0　　　　　　　　　　　|　10
		---+---------------------------------------------------------+-----
		 5 | 　　　　　　　　　　Base Address 1　　　　　　　　　　　|　14
		---+---------------------------------------------------------+-----
		 6 | 　　　　　　　　　　Base Address 2　　　　　　　　　　　|　18
		---+---------------------------------------------------------+-----
		 7 | 　　　　　　　　　　Base Address 3　　　　　　　　　　　|　1C
		---+---------------------------------------------------------+-----
		 8 | 　　　　　　　　　　Base Address 4　　　　　　　　　　　|　20
		---+---------------------------------------------------------+-----
		 9 | 　　　　　　　　　　Base Address 5　　　　　　　　　　　|　24
		---+---------------------------------------------------------+-----
		10 | 　　　　　　　　　CardBus CIS pointer　　　　　　　　　 |　28
		---+---------------------------------------------------------+-----
		11 |　　Subsystem Device ID　　| 　　Subsystem Vendor ID　　 |　2C
		---+---------------------------------------------------------+-----
		12 | 　　　　　　　Expansion ROM Base Address　　　　　　　　|　30
		---+---------------------------------------------------------+-----
		13 | 　　　　　　　Reserved(Capability List)　　　　　　　　 |　34
		---+---------------------------------------------------------+-----
		14 | 　　　　　　　　　　　Reserved　　　　　　　　　　　　　|　38
		---+---------------------------------------------------------+-----
		15 | 　Max_Lat　 | 　Min_Gnt　 | 　IRQ Pin　 | 　IRQ Line　　|　3C
		-------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Registers Meanings:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Device ID &amp;amp; Vendor ID: The manufacturer of a device and the specific device are marked. For example, the Vendor ID of Intel’s device is usually 0x8086, and the Device ID is determined by the manufacturer.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Class code: There are three bytes in total, which are class code, subclass code, and programming interface. The class code is not only used to distinguish the device type, but also the specification of the programming interface&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IRQ Line: The PC used to manage 16 hardware interrupts by two 8259 chips. Now in order to support symmetric multi-processors, there is APIC (Advanced Programmable Interrupt Controller), which supports the management of 24 interrupts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IRQ Pin: PCI has 4 interrupt pins. This register indicates which pin the device is connected to.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Use &lt;code&gt;lspci&lt;/code&gt; command to see the info of pci devices.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;parallels@parallels-Parallels-Virtual-Platform:~$ lspci -mk
00:00.0 &quot;Host bridge&quot; &quot;Intel Corporation&quot; &quot;82P965/G965 Memory Controller Hub&quot; -r02 &quot;Parallels, Inc.&quot; &quot;82P965/G965 Memory Controller Hub&quot;
00:01.0 &quot;PCI bridge&quot; &quot;Intel Corporation&quot; &quot;82G35 Express PCI Express Root Port&quot; -r02 -p01 &quot;&quot; &quot;&quot;


parallels@parallels-Parallels-Virtual-Platform:~$ lspci -vv
00:00.0 Host bridge: Intel Corporation 82P965/G965 Memory Controller Hub (rev 02)
	Subsystem: Parallels, Inc. 82P965/G965 Memory Controller Hub
	Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx-
	Status: Cap+ 66MHz- UDF- FastB2B+ ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
	Latency: 0

00:01.0 PCI bridge: Intel Corporation 82G35 Express PCI Express Root Port (rev 02) (prog-if 01 [Subtractive decode])
	Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx-
	Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
	Latency: 0
	Bus: primary=00, secondary=01, subordinate=01, sec-latency=0
	I/O behind bridge: 00006000-00007fff
	Memory behind bridge: e2000000-edffffff
	Prefetchable memory behind bridge: 00000000b0000000-00000000dfffffff
	Secondary status: 66MHz- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;lt;SERR- &amp;lt;PERR-
	BridgeCtl: Parity+ SERR+ NoISA- VGA+ MAbort- &amp;gt;Reset- FastB2B-
		PriDiscTmr- SecDiscTmr- DiscTmrStat- DiscTmrSERREn-
	Capabilities: &amp;lt;access denied&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;1-create-pci-device&quot;&gt;1 Create PCI device&lt;/h2&gt;

&lt;p&gt;Look into the file &lt;a href=&quot;https://github.com/qemu/qemu/blob/master/hw/misc/edu.c&quot;&gt;/hw/misc/edu.c&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static void pci_edu_register_types(void)
{
    static InterfaceInfo interfaces[] = {
        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
        { },
    };
    static const TypeInfo edu_info = {
        .name          = TYPE_PCI_EDU_DEVICE,
        .parent        = TYPE_PCI_DEVICE,
        .instance_size = sizeof(EduState),
        .instance_init = edu_instance_init,
        .class_init    = edu_class_init,	// pci device init func
        .interfaces = interfaces,
    };

    type_register_static(&amp;amp;edu_info); // register device structure
}
type_init(pci_edu_register_types)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In func &lt;code&gt;edu_class_init&lt;/code&gt;, the content of configuration space is written. What’s more, the member of  PCIDeviceClass &lt;code&gt;realize&lt;/code&gt; is set as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static void edu_class_init(ObjectClass *class, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(class);
    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);

    k-&amp;gt;realize = pci_edu_realize;
    k-&amp;gt;exit = pci_edu_uninit;
    k-&amp;gt;vendor_id = PCI_VENDOR_ID_QEMU;
    k-&amp;gt;device_id = 0x11e8;
    k-&amp;gt;revision = 0x10;
    k-&amp;gt;class_id = PCI_CLASS_OTHERS;
    set_bit(DEVICE_CATEGORY_MISC, dc-&amp;gt;categories);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Member &lt;code&gt;realize&lt;/code&gt; is a function pointer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void (*realize)(PCIDevice *dev, Error **errp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function pointed to is  &lt;code&gt;pci_edu_realize&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static void pci_edu_realize(PCIDevice *pdev, Error **errp)
{
    EduState *edu = EDU(pdev);
    uint8_t *pci_conf = pdev-&amp;gt;config;

    pci_config_set_interrupt_pin(pci_conf, 1);

    if (msi_init(pdev, 0, 1, true, false, errp)) {
        return;
    }

    timer_init_ms(&amp;amp;edu-&amp;gt;dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);

    qemu_mutex_init(&amp;amp;edu-&amp;gt;thr_mutex);
    qemu_cond_init(&amp;amp;edu-&amp;gt;thr_cond);
    qemu_thread_create(&amp;amp;edu-&amp;gt;thread, &quot;edu&quot;, edu_fact_thread,
                       edu, QEMU_THREAD_JOINABLE);

    memory_region_init_io(&amp;amp;edu-&amp;gt;mmio, OBJECT(edu), &amp;amp;edu_mmio_ops, edu,
                    &quot;edu-mmio&quot;, 1 * MiB);	// register MemoryRegion struct, alloc
    pci_register_bar(pdev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;amp;edu-&amp;gt;mmio);	// register a bar whose type is mmio
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2-data-communication&quot;&gt;2 Data Communication&lt;/h2&gt;

&lt;p&gt;After the emulation of device info and memory region, the most significant part needs to be resolve. The establishment of communication channel between the PCI driver of linux kernel and the PCI device emulated by QEMU.&lt;/p&gt;

&lt;h3 id=&quot;21-read-and-write&quot;&gt;2.1 Read and Write&lt;/h3&gt;

&lt;p&gt;Let’s focus on the function &lt;code&gt;edu_mmio_read&lt;/code&gt; and &lt;code&gt;edu_mmio_write&lt;/code&gt; who have defined the I/O operations.&lt;/p&gt;

&lt;p&gt;What is the real ability of this device?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A driver with I/Os, IRQs, DMAs and such.&lt;/p&gt;

  &lt;p&gt;The devices behaves very similar to the PCI bridge present in the COMBO6 cards developed under the Liberouter wings.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;According to the addr which is the offset, the operator can set or get the different properties. With these various behavoirs.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;edu_mmio_read&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;addr&lt;/th&gt;
      &lt;th&gt;size (Byte)&lt;/th&gt;
      &lt;th&gt;info&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0x00&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;const&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x04&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;EduState / addr4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x08&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;EduState / fact&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x20&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;EduState / status&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x24&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;EduState / irq_status&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x80&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;EduState / dma_state / src&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x88&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;EduState / dma_state / dst&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x90&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;EduState / dma_state / cnt&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x98&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;EduState / dma_state / cmd&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;edu_mmio_write&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;addr&lt;/th&gt;
      &lt;th&gt;size (Byte)&lt;/th&gt;
      &lt;th&gt;info&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0x04&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;EduState / addr4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x08&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;EduState / fact (Mutex)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x20&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;EduState / status&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x60&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;edu_raise_irq&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x64&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;edu_lower_irq&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x80&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;EduState / dma_state / src&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x88&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;EduState / dma_state / dst&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x90&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;EduState / dma_state / cnt&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0x98&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;EduState / dma_state / cmd&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;22-dma&quot;&gt;2.2 DMA&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static void edu_dma_timer(void *opaque)
{
    EduState *edu = opaque;
    bool raise_irq = false;

    if (!(edu-&amp;gt;dma.cmd &amp;amp; EDU_DMA_RUN)) {
        return;
    }

    if (EDU_DMA_DIR(edu-&amp;gt;dma.cmd) == EDU_DMA_FROM_PCI) {
        uint64_t dst = edu-&amp;gt;dma.dst;
        edu_check_range(dst, edu-&amp;gt;dma.cnt, DMA_START, DMA_SIZE);
        dst -= DMA_START;
        pci_dma_read(&amp;amp;edu-&amp;gt;pdev, edu_clamp_addr(edu, edu-&amp;gt;dma.src),
                edu-&amp;gt;dma_buf + dst, edu-&amp;gt;dma.cnt);
    } else {
        uint64_t src = edu-&amp;gt;dma.src;
        edu_check_range(src, edu-&amp;gt;dma.cnt, DMA_START, DMA_SIZE);
        src -= DMA_START;
        pci_dma_write(&amp;amp;edu-&amp;gt;pdev, edu_clamp_addr(edu, edu-&amp;gt;dma.dst),
                edu-&amp;gt;dma_buf + src, edu-&amp;gt;dma.cnt);
    }

    edu-&amp;gt;dma.cmd &amp;amp;= ~EDU_DMA_RUN;
    if (edu-&amp;gt;dma.cmd &amp;amp; EDU_DMA_IRQ) {
        raise_irq = true;
    }

    if (raise_irq) {
        edu_raise_irq(edu, DMA_IRQ);
    }
}

static void dma_rw(EduState *edu, bool write, dma_addr_t *val, dma_addr_t *dma,
                bool timer)
{
    if (write &amp;amp;&amp;amp; (edu-&amp;gt;dma.cmd &amp;amp; EDU_DMA_RUN)) {
        return;
    }

    if (write) {
        *dma = *val;
    } else {
        *val = *dma;
    }

    if (timer) {
        timer_mod(&amp;amp;edu-&amp;gt;dma_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 100);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to the members of &lt;code&gt;dma_state&lt;/code&gt;, the state of DMA can be decided, is the last bit of &lt;code&gt;cmd&lt;/code&gt; is 1. It means that DMA is running. The corresponding rw operation can be done with function &lt;code&gt;dma_rw&lt;/code&gt; and the bool variable &lt;code&gt;write&lt;/code&gt;.&lt;/p&gt;

</description>
        <pubDate>Sat, 05 Sep 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/jekyll/update/2020/09/05/Begin-with-QEMU-educational-PCI-device/</link>
        <guid isPermaLink="true">http://localhost:4000/jekyll/update/2020/09/05/Begin-with-QEMU-educational-PCI-device/</guid>
      </item>
    
      <item>
        <title>Struct MachineClass in QEMU</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Auther: Percy&lt;/p&gt;

  &lt;p&gt;Updated at 2020/8/28&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Before looking at the specific structure, let us have a glance on the use of this structure in the project.&lt;/p&gt;

&lt;p&gt;Begin with the main entrance file &lt;a href=&quot;https://github.com/qemu/qemu/blob/master/softmmu/vl.c&quot;&gt;/softmmu/vl.c&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Markdown&quot;&gt;
{% mermaid %}
graph TD;
    A--&amp;gt;B;
    A--&amp;gt;C;
    B--&amp;gt;D;
    C--&amp;gt;D;
{% endmermaid %}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In func &lt;code&gt;qemu_init&lt;/code&gt;, we will have two rounds of option parsing. In the first pass of option parsing, count the number of options and validate the legality of options.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;    /* first pass of option parsing */
    optind = 1;
    while (optind &amp;lt; argc) {
        if (argv[optind][0] != '-') {
            /* disk image */
            optind++;
        } else {
            const QEMUOption *popt;

            popt = lookup_opt(argc, argv, &amp;amp;optarg, &amp;amp;optind);
            switch (popt-&amp;gt;index) {
            case QEMU_OPTION_nouserconfig:
                userconfig = false;
                break;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there is a speial case &lt;code&gt;QEMU_OPTION_nouserconfig&lt;/code&gt;. It represents that if this argument exsits, the configuration process will use the corresponding config file. After this first pass, the second pass will start to fill the option list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;            case QEMU_OPTION_machine:
                olist = qemu_find_opts(&quot;machine&quot;);
                opts = qemu_opts_parse_noisily(olist, optarg, true);
                if (!opts) {
                    exit(1);
                }
                break;
...
    machine_class = select_machine();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In func &lt;code&gt;select_machine&lt;/code&gt;,  get a single-linked list of &lt;code&gt;MachineClass&lt;/code&gt; at first with function &lt;code&gt;object_class_get_list&lt;/code&gt;.  Walk this list to find the default value. Then get the machine_opts and extract the &lt;code&gt;type&lt;/code&gt; property. Pass this string and previous list to func &lt;code&gt;machine_parse&lt;/code&gt;. The target class will be given by the func &lt;code&gt;find_machine&lt;/code&gt;  through the comparasion of name property. (If hlep option attached, all supported classes which are sorted and default class will be shown. )&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;After got the target class, qemu can do initialization with it. With the analysis of the properties which is hold by &lt;code&gt;MachineClass &lt;/code&gt;, the understanding of its role may be easier. The detailed descriptions are all added in the appendix.&lt;/p&gt;

&lt;h2 id=&quot;appendix&quot;&gt;Appendix&lt;/h2&gt;

&lt;h3 id=&quot;machineclass-definition&quot;&gt;MachineClass Definition&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct MachineClass {
    /*&amp;lt; private &amp;gt;*/
    ObjectClass parent_class;
    /*&amp;lt; public &amp;gt;*/

    const char *family; /* NULL iff @name identifies a standalone machtype */
    char *name;
    const char *alias; /* another name */
    const char *desc;
    const char *deprecation_reason; /* If set, the machine is marked as deprecated. The
    string should provide some clear information about what to use instead. */

    /* provided func */
    void (*init)(MachineState *state);
    void (*reset)(MachineState *state);
    void (*wakeup)(MachineState *state);
    void (*hot_add_cpu)(MachineState *state, const int64_t id, Error **errp);
/**
 *    @kvm_type:
 *    Return the type of KVM corresponding to the kvm-type string option or
 *    computed based on other criteria such as the host kernel capabilities.
 */
    int (*kvm_type)(MachineState *machine, const char *arg);
    
/**
 *    @smp_parse:
 *    The function pointer to hook different machine specific functions for
 *    parsing &quot;smp-opts&quot; from QemuOpts to MachineState::CpuTopology and more
 *    machine specific topology fields, such as smp_dies for PCMachine.
 */
    void (*smp_parse)(MachineState *ms, QemuOpts *opts);

    BlockInterfaceType block_default_type;
    int units_per_default_bus;
    int max_cpus; /* maximum number of CPUs supported. Default: 1 */
    int min_cpus; /* minimum number of CPUs supported. Default: 1 */
    int default_cpus; /* number of CPUs instantiated if none are specified. Default: 1 */
    unsigned int no_serial:1,
        no_parallel:1,
        no_floppy:1,
        no_cdrom:1,
        no_sdcard:1,
        pci_allow_0_address:1,
        legacy_fw_cfg_order:1;
    bool is_default; /* If true QEMU will use this machine by default if no '-M' option is given. */
    const char *default_machine_opts;
    const char *default_boot_order;
    const char *default_display;
    GPtrArray *compat_props;
    const char *hw_version; /* Value of QEMU_VERSION when the machine was added to QEMU. */
    ram_addr_t default_ram_size;
    const char *default_cpu_type; /* specifies default CPU_TYPE, which will be used for parsing target specific features and for creating CPUs if CPU name wasn't provided explicitly at CLI */
    bool default_kernel_irqchip_split;
    bool option_rom_has_mr;
    bool rom_file_has_mr;
    int minimum_page_bits; /* If non-zero, the board promises never to create a CPU with a page size smaller than this */
    bool has_hotpluggable_cpus; /* If true, board supports CPUs creation with -device/device_add. */
    bool ignore_memory_transaction_failures; /* If this is flag is true then the CPU will ignore memory transaction failures which should cause the CPU to take an exception due to an access to an unassigned physical address */
    int numa_mem_align_shift;
    const char **valid_cpu_types;
    strList *allowed_dynamic_sysbus_devices;
    bool auto_enable_numa_with_memhp;
    bool auto_enable_numa_with_memdev;
    void (*numa_auto_assign_ram)(MachineClass *mc, NodeInfo *nodes,
                                 int nb_nodes, ram_addr_t size);
    bool ignore_boot_device_suffixes;
    bool smbus_no_migration_support;
    bool nvdimm_supported;
    bool numa_mem_supported; /* true if '--numa node.mem' option is supported  */
    bool auto_enable_numa;
    const char *default_ram_id; /* Specifies inital RAM MemoryRegion name */

/**
 * 	  @hotplug_allowed:
 *    If the hook is provided, then it'll be called for each device
 *    hotplug to check whether the device hotplug is allowed.  Return
 *    true to grant allowance or false to reject the hotplug.  When
 *    false is returned, an error must be set to show the reason of
 *    the rejection.  If the hook is not provided, all hotplug will be
 *    allowed.
 */
    HotplugHandler *(*get_hotplug_handler)(MachineState *machine,
                                           DeviceState *dev);
    
/**
 *    @get_hotplug_handler: this function is called during bus-less
 *    device hotplug. If defined it returns pointer to an instance
 *    of HotplugHandler object, which handles hotplug operation
 *    for a given @dev. It may return NULL if @dev doesn't require
 *    any actions to be performed by hotplug handler.
 */
    bool (*hotplug_allowed)(MachineState *state, DeviceState *dev,
                            Error **errp);
/**
 *    @cpu_index_to_instance_props:
 *    used to provide @cpu_index to socket/core/thread number mapping, allowing
 *    legacy code to perform maping from cpu_index to topology properties
 *    Returns: tuple of socket/core/thread ids given cpu_index belongs to.
 *    used to provide @cpu_index to socket number mapping, allowing
 *    a machine to group CPU threads belonging to the same socket/package
 *    Returns: socket number given cpu_index belongs to.
 */
    CpuInstanceProperties (*cpu_index_to_instance_props)(MachineState *machine,
                                                         unsigned cpu_index);
    
/**
 *    @possible_cpu_arch_ids:
 *    Returns an array of @CPUArchId architecture-dependent CPU IDs
 *    which includes CPU IDs for present and possible to hotplug CPUs.
 *    Caller is responsible for freeing returned list.
 */
    const CPUArchIdList *(*possible_cpu_arch_ids)(MachineState *machine);
    
/**
 *    @get_default_cpu_node_id:
 *    returns default board specific node_id value for CPU slot specified by
 *    index @idx in @ms-&amp;gt;possible_cpus[]
 */
    int64_t (*get_default_cpu_node_id)(const MachineState *ms, int idx);
    
/**
 *    @fixup_ram_size
 *    Amends user provided ram size (with -m option) using machine specific 
 *    algorithm. To be used by old machine types for compat purposes only.
 */  
    ram_addr_t (*fixup_ram_size)(ram_addr_t size);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;glossary&quot;&gt;Glossary&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;bus-less device: [Waiting to be added]&lt;/li&gt;
  &lt;li&gt;numa: Non-uniform memory access&lt;/li&gt;
  &lt;li&gt;kvm: Kernel-based Virtual Machine&lt;/li&gt;
  &lt;li&gt;smp: Symmetric multiprocessing&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 28 Aug 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/jekyll/update/2020/08/28/Struct-MachineClass-in-QEMU/</link>
        <guid isPermaLink="true">http://localhost:4000/jekyll/update/2020/08/28/Struct-MachineClass-in-QEMU/</guid>
      </item>
    
  </channel>
</rss>
